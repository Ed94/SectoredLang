// This is based directly on the zpl.h source.


expose // A symbol will be generated at translation time with the following parameters accounted for during translation.
// tt + exe : Generate inplace
DArray tt depend (Type : Type, AllocatorType : PAL.AllocatorType);
// DArray__Depend_Type__PAL.AllocatorType
// In a symbol abi symbol viewer 

DArray 
{
	tt if AllocatorType != undefined : 
		exe { heap : allocator = AllocatorType; }
	;

	expose type	ptr struct :
		Length : uw;
		Data   : ptr Type;
	;

	// Internal (true) data type.
	Header type struct
	{
		// If the allocator is not defined at translation time,
		// reference an allocator using a rutnime reference.
		tt macro OptionalAllocator
		{
			tt if AllocatorType == undefined :
				exe { Allocator : PAL.Allocator }
			;
		}

		OptionalAllocator;
		Capacity  : uw;
		Length    : uw;
		Data      : ptr byte;
	}

	tt macro
	if AllocatorType == undefined :
		OptionalAllocatorParam exe { _Allocator : PAL.Allocator }
	;

	proc :
		GrowFormula (_capacity : uw) -> uw inline;
	;

	expose proc (self : ptr <Type> DArray) : 
		Init        (OptionalAllocatorParam) inline;
		InitCopy	(_other : ptr <Type> DArray)
		InitReserve (_capacity : uw, OptionalAllocatorParam);

		Append  (_obj  : Type);
		AppendAt(_obj  : Type, _index  : uw);

		Append  (_objs : [] Type, _amount : uw);
		AppendAt(_objs : [] Type, _amount : uw, _index uw);

		Back -> ptr Type;
		Clear;

		Fill(_begin, _end : uw, _value : ptr Type)
		Free;

		GetHeader -> ptr Header inline;

		Grow       (_minCapacity : uw);
		PopBack	   ()
		RemoveAt   (_index : uw);
		Resize     (_newLength : uw);
		Reserve    (_capacity : uw);
		SetCapacity(_capacity : uw);
	;
}

// Explicitly generate a DArray of u32.
tt exe DArray(u32);
// DArray__depend_u32_undef

