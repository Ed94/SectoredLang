MAS (Modular Alias Sectored)

An experimental langauge for figuring out stuff I wanted in langauges

I have tried serveral different ways to break down the langauge this is around my third or forth attempt

A project is an encapsulated unit that specifies a program
A package is an encapsulated unit that may be used by a project
Projects can be a package for another project.
#------------------------------------------------------------------------------------------------------------------
File/Unit associations :
.context              Context unit for a project or package. Determines how the related content will be processed
.bp                   Specifies an outline to a subject unit
.spec                 Specifies a unit of definitions and descriptions that may be composed into a program
.alias                Used for external ABI, foreign language support, and custom language model specification
#------------------------------------------------------------------------------------------------------------------
Backend Modules :
These are domain specific compatiable translation modules to handle MAS programs.

Backend Categories :
ISA            Instruction Set Architecture (x86, ARM, RISC, etc). Machine code signal interface modules
Assembler      ISA supported assembler modules
IR             Intermediary representation compiler framework. Universal assembly module
Compiler       Low (L0) to high (L4) level compiled language. Can use the previous modules to support translation
Interpreter    Runtime interpreter for the same language specification used of for the compiler

Meta           Metaprogramming module supporting rudimentary macros, to advanced macro syntax systems. 
               Handles directives to tooling. These directives unlike alias are more related to traditional pragmas
               of the backend or things related to how the code is handled.
               Templating and generics must be done with a meta specifier.
               
Alias          Provides similar to functionality to using statements or typedefs in c++ along with being able to 
               specify ammendments the backend language modules such as the lexer, parser, and symbol table.
               As such things related to the langauge model can be changed. 
               (So long as the alias backend allows for it)
               
Note: I'm not entirely aware where I'm going to put generics/templating, but most likely with be in meta specified.
#------------------------------------------------------------------------------------------------------------------
Langauge Feature Layering :

All language/module features can be explicitly disabled or enabled in context specification
Generalized set of featuers are group into layers from layer 0 to layer 4


Layer 0         Low-level features, binary, hex, interrupts, paging, stack, registers, etc.
Layer 1         C Features
Layer 2         Memory and execution safety, garbage collection, V-Table generation, etc        
Layer 3         C++ level of expressability
Layer 4         Declarative with dependent types
#------------------------------------------------------------------------------------------------------------------
#------------------------------------------------------------------------------------------------------------------
.context                Context Specification

symbols:
    context             Provides a designated named context unit for a project
	description			Description for context
    modules             States what backend modules to use for program specification
    layers              Specifies which language layers are implicity allowed. (To allow none, leave empty)
    explicit layers     Whether or not layers may be explicitly allowed within units
    alias               Specifies either the model language standard or support for an external language syntax
    dependencides       States what external packages this context depends on
    alias               Allows for in context appending of the current alias set (intended for small additions)
    units/files         Used to specify what units or files are associated with the context
    entrypoint          Specifies the execution entrypoint (if the context is a program)
#------------------------------------------------------------------------------------------------------------------
.bp                     Blueprint

Serve a few purposes :

    An Outline              Blueprints provide a clean outline for unit/s encapsulated as subject
    Conflict Avoidance      In conjunction with contexts and alias sets, blueprints prevent circular 
                            dependency issues or issues with symbol resolution
    Package Optimization    Allow the backend to cache and process packing and context efficiently
    Unit/s sectoring        Acts as a namespace for a set of implementation

Note: While it is ideal, blueprints could also be generated if desired (intended feature later on)

A blueprint's syntax closely follows the language model used for spec units
#------------------------------------------------------------------------------------------------------------------
.spec                   Specification

Where a unit of implementation for a subject or context is defined
There can be multiple units for each bp (blueprint)
#------------------------------------------------------------------------------------------------------------------
.gen.*                  Generated Specification

These are generated units that have completed the meta and/or ct pass.
These files are optionally outputted to the filesystem.
These files are mainly intended to be rendered or debugged in a mas compatiable editor.

The purpose is to provide an visual of how meta-programming (alias, meta, ct) features are generated in a clear way.
#------------------------------------------------------------------------------------------------------------------
.db                     Database

This is a full image of a processed context.
Which includes the structured table organized by the context and subject units.
Contains all unit defined symbols and their properites along with AST of execution specification.
These are meant to be saved to cache previous passes or as an intermediary between tools.

Should be viewable using a database viewer.
#------------------------------------------------------------------------------------------------------------------
.ast                    Abstract Syntax There

This is a metadesk (hopefully) formatted ast file that contains the raw parsed ast of a context. 
This can be used as intermediary between tools or as a way to store the "live" source code.
Unit text files can be generated from the ast.

This is meant to be the live "code" the user writes source code in with a toolchain. ASTs should be rendered live
in "tiled" or "tokened" text.
#====================================================================================================================
#\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
#====================================================================================================================
Language Model Specification :

Statically Typed

Identifier lazy evalutation, not based on order of introduction of definition. (Via backend multi-pass)

Tokens Types :
#--------------------------------------------------------------------------------------------------------------------
Comment
Components
Formatting
Parameters
Literal
    Digit
    Character
    String
Sector
Statement
Operator
#--------------------------------------------------------------------------------------------------------------------

Universal Context:
#--------------------------------------------------------------------------------------------------------------------
                                                        Comments
//              Comment Line            cmt_SS
/-              Start Comment           cmt_SC
-/              End Comment             cmt_EC
#------------------------------------------------------
                                                        Components
' '             Whitespace              comp_WS
'_'             Underscore              comp_UnderS
\0              Null Terminator         comp_Null             
EOF             End of file             comp_EOF
'"'             Stirng Dilimiter        comp_SDilim
#------------------------------------------------------
                                                        Formatting (Ignored by the compiler)
" ..."          Whitespace String       fmt_WSS
\n              NewLine                 fmt_NL
{               Open Brace              fmt_OB
}               Close Brace             fmt_CB
#------------------------------------------------------
                                                        Parameters
(               Parenthesis Start        params_PStart
)               Parenthesis End          params_PEnd
<               Angle Bracket Start      params_ABStart
>               Angle Bracket End        params_ABEnd
[               Square Bracket Start     params_SBStart
]               Square Bracket End       params_SBEnd
#------------------------------------------------------
                                                        Operators
.               Member Resolution       op_SMA
->              Map Resolution          op_Map
#------------------------------------------------------
                                                        Literals
'$'             Character               literal_Char
0b{0-1}         Binary                  literal_Binary
0t{0-2}         Ternary          		literal_Ternary
0o{0-7}         Octal                   literal_Octal
0x{0-F}         Hex                     literal_Hex
{0-9}...        Decimal Digits          literal_Digit                        
"..."           String                  literal_String
#------------------------------------------------------
                                                        Sectors
alias           Aliasing                sec_alias
#append          Symbol Appending        sec_append
ct              Compile Time            sec_ct
else            Coniditonal Else        sec_else
enum            Enumeration             sec_enum    
#expose          Expose Definitions      sec_expose
{Identifer}     Symbol Definitions      sec_DefSym
if              Conditional If          sec_if
in              Expose Member Symbols   sec_in
layer           Explicit layer use      sec_layer
meta            Metaprogramming         sec_meta          
#-------------------------------------------------------
                                                        Statements
:               start def block         def_Start
;               end   def block         def_End
,               Comma delimiter         def_CD
#-------------------------------------------------------
                                                        Symbols
{Identifier}    User defined symbol     sym_Identifier
type            Top Type                sym_TType
{undefined}     Invalid Token           sym_Invalid
#====================================================================================================================
Universal Grammar:
#--------------------------------------------------------------------------------------------------------------------
...                             Symbol pattern generator

identifier : body ;             Symbol defining statement
identifier : symbol ;           Symbol associated with identifier

(symbol, ...)                   Parenthesized expression symbol defining statement
<symbol, ...>                   Angle bracketed expression symbol defining statement
[symbol, ...]                   Square bracketed expression symbol defining statement

symbol[symbol]                  Access element of symbol
symbol::symbol                  Access symbol associated with symbol

specifier {(..., ...)} symbol   Specify specifier with optional parameterized flags for symbol

symbol -> symbol                Symbol mapping to other symbol

{symbol} identifier             specify symbol for one identifier
{symbol} : body ;               specify symbol for body

typeof(identifier)              Accessor to associated type of identifier
#\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
#====================================================================================================================

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Layer 0

APS : 1
Untyped
User identifier sector nesting is not allowed.
Nesting alias in Meta is not allowed.
Nesting meta in alias is not allowed.

Tokens :
#------------------------------------------------------
                                                        Operators
            # Inference
alignof         Alignment Accessor      op_alingof
#identifier      Identifier              op_identifier
offsetof        Member Offset           op_offsetof
posof           Member Position         op_posof
sizeof          Symbol memory           op_sizeof
            # Indirection
ptr             Pointer accessor        op_ptr
val             Value Accessor          op_val
            # Execution
ret             Return                  op_return
pop             Pop current stack       op_pop
push            Push current stack      op_push
goto            Jump to Label           op_goto
continue        Jump to start of loop   op_continue
break           Jump out of block       op_break
#{PI};           # Procedure Identifier
#{PI}<...>(...); Call Procedure          op_callproc
            # Logical
!               Logical NOT             op_LNOT
&&              Logical And             op_LAND
||              Logical OR              op_LOR    
&               Bitwise And             op_BAND
|               Bitwise Or              op_BOR
^               Bitwise XOr             op_BXOR
~               Bitwise Not             op_BNOT
<<              Bitwise Shift Left      op_BSL
>>              Bitwise Shift Right     op_BSR
            # Arithmetic
+               Addition                op_Add
-               Subtraction             op_Subtract
*               Multiply                op_Multiply
/               Divide                  op_Divide
%               Modulo                  op_Modulo
++              Increment               op_Increment
--              Decrement               op_Decrement
==              Equals                  op_Equal
!=              Not Equal               op_NotEqul
>=              Greater Equal           op_GreaterEqual
<=              Lesser Equal            op_LesserEqul
            # Assignment
=               Assignment              op_ASSIGN
&=              Assign Bit And          op_AB_And
|=              Assign Bit Or           op_AB_Or
^=              Assign Bit XOr          op_AB_XOr
~=              Assign Bit Not          op_AB_Not
<<=             Assign Bit Shift Left   op_AB_SL
>>=             Assign Bit Shift Right  op_AB_SR
+=              Assign Add              op_A_Add
-=              Assign Subtract         op_A_Subtract
*=              Assign Multiple         op_A_Multiply
/=              Assign Divide           op_A_Divide
%=              Assign Modulo           op_A_Modulo
#-------------------------------------------------------
                                                        Sectors
			# Encoding
binary          Binary  block           sec_Binary
ternay          Ternary block           sec_Ternary
octal           Octal   block           sec_Octal
hex             Hex     block           sec_Hex

            # Meta-programming				
embed			Embed Data				sec_Embed
ro              Read-only               sec_Ro
inline          Redefine inplace        sec_Inline

			# Control Flow
label           Label                   sec_Lable
loop            Loop execution          sec_Loop

			# Memory
align           Alignment               sec_Align
mpage           Memory Paging Segments  sec_Mempage
register        Register Type           sec_Register
stack           Stack  Segment          sec_Stack
static          Static Segment          sec_Static
strict          Strict reference        sec_Strict
struct          Data Record/ Structure  sec_Struct   
volatile        Volatile reference      sec_Volatile

            # Execution
interrupt       Interrupt               sec_Interrupt
proc            Procedure               sec_Proc

#-------------------------------------------------------
                                                        Symbols
ptr             Address Pointer                     sym_Ptr
byte            Smallest addressable unit of bits   sym_Byte
word            Machine data model width            sym_Word
#====================================================================================================================
Grammar :
#-------------------------------------------------------
ret   symbol;                   Return a valid symbol for the context   
label identifier;               Deifne label with identifier
goto  identifier;               Jump to identitfier

alignof(identifier)             Alignment of struct member
offsetof(identifier)            Offset of struct member
posof(identifier)               Position of struct member
sizeof(identifier)              Size of struct or a type symbol

ptr type                        Defines a pointer to a type
symbol.ptr                      Accessor to pointer of a symbol
symbol.val                      Value of pointer type associated symbol

identfier {assign op} value     Assign value to identifier
value op ...                    perform operation on value (delimiter)
op(value, ...)                  perform operation on values (functional)

sizeof(symbol) * width          Specify a datatype of set width (where width is a digit literal)
#\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
#====================================================================================================================

# ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
Below not fleshed out
#\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
Layer 1

Weak typing.
By default all data is mutable
User identifier sector nesting is not allowed implicitly.

Removed:
#-------------------------------------------------------
binary
ternary
hex
interrupt
page
pop
push
#====================================================================================================================

Tokens :
#------------------------------------------------------
                                                        Parameters
#------------------------------------------------------
                                                        Operators
#::              Scope Resolution        op_SSA

allocate        allocate heap           op_Alloc
deallocate      deallocate heap         op_Dealloc

cast            Type cast               op_Cast
typeof          Type Accessor           op_TypeOf
#------------------------------------------------------
                                                        Sector
heap            Heap Memory block       sec_Heap
for             For loop                sec_For
#-------------------------------------------------------
                                                        Statements
#-------------------------------------------------------
                                                        Symbols
#====================================================================================================================
Grammar :
#-------------------------------------------------------
#\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
#===================================================================================================================
Layer 2

By default all data is read-only.
Strong Typing
Borrow Checker
User identifier sector nesting is allowed with limitations.

Removed:
label
goto

Tokens :
#------------------------------------------------------
                                                        Parameters
#------------------------------------------------------
                                                        Operators
#------------------------------------------------------
                                                        Sector
interface   Dispatch Specification      sec_Interface
gc          Garbage Collector           sec_GC
zone        Zone Memory                 sec_MemZone
mut         Mutable                     sec_Mut
trait       Static Dispatch             sec_Trait
virtual     Dynamic Dispatch            sec_Virtual
#-------------------------------------------------------
                                                        Statements
#-------------------------------------------------------
                                                        Symbols
ref         References                  sec_Ref                                                        
#====================================================================================================================
Grammar :
#-------------------------------------------------------
#\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
#====================================================================================================================
Layer 3

Strong typing
By default all data is read-only.
There are no restrictions on user identifier sector nesting.

Removed:

#====================================================================================================================

Tokens :
#------------------------------------------------------
                                                        Parameters
#------------------------------------------------------
                                                        Operators
#------------------------------------------------------
                                                        Sector
#-------------------------------------------------------
                                                        Statements
#-------------------------------------------------------
                                                        Symbols
#====================================================================================================================
Grammar :
#-------------------------------------------------------
#\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
#====================================================================================================================
Layer 4

Dependent typing
There is no imperative execution bodies.
There are no restrictions on symbol-statement body nesting.

Tokens :
#------------------------------------------------------
                                                        Parameters
#------------------------------------------------------
                                                        Operators
#------------------------------------------------------
                                                        Sector
fn          Function                    sec_FN
#-------------------------------------------------------
                                                        Statements
#-------------------------------------------------------
                                                        Symbols
#====================================================================================================================
Grammar :
#-------------------------------------------------------
#\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\
#====================================================================================================================


#------------------------------------------------------------------------------------------------------------------

#====================================================================================================================
#\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\