// BP

Memory 
{
	Block struct
	{
		Location : ptr uw;
		Size     :     uw;
	}

	BlockArray struct
	{
		Data   : []ptr Block;
		Length : uw
	}

	BlockArray (self)
	{
		Add -> ptr Block;

		(heap)
		{
			(tt Type : type)
			{
				allocate (numDesired : uw)                     -> ptr Type;
				resize   (address : ptr Type, numDesired : uw) -> ptr Type;
			}
		}

		free;
	}

	(heap)
	{
		(tt Type : type)
		{
			allocate (numDesired : uw)                     -> ptr Type;
			resize   (address : ptr Type, numDesired : uw) -> ptr Type;
		}

		free;
	}

	// Format
	// {
	// 	WithData()
	// }
}

// Unit

Memory
{
	static GlobalAllocs : BlockArray;

	BlockArray (self)
	{
		Add -> ptr Block exe
		{
			if Data == null
			{
				heap Data : LP.allocate(1);

				check(Data, "Failed to globally allocate block array")

				Length = 1;
			}
			else
			{
				stack {
					newSize  : u32       = Length + 1;
					newBlock : ptr Block = null;
				}

				heap newBlock : LP.allocate(newSize);

				if newBlock
				{
					Format.Set(newBlock, Data, Length);

					Data = newBlock;
				}
				
				else throw("Failed to globally reallocate block array");
			}

			heap Data[Length - 1] : LP.allocate(1);
			ret  Data[Length - 1];
		}

		(heap)
		{
			(tt Type : type)
			{
				// ResolvedSymbol: Memory.BlockArray.allocate (self, heap, tt Type : type, numDesired : uw) -> ptr Type exe
				allocate (numDesired : uw) -> ptr Type exe
				{
					stack newBlock : ptr Block = Add();

					newBlock.Size = numDesired * Type.sizeof;
					
					heap newBlock.Location : LP.allocate(numDesired * Type.sizeof);

					check(newBlock.Location, "Failed to allocate block")

					ret cast(ptr Type, newBlock.Location);
				}

				resize(address : ptr Type, numDesired : uw) -> ptr Type exe
				{
					stack index : uw = 0; loop 
					{
						if index >= Length 
							ret null

						if Data[index].Location == address
							break;
					}

					stack newLocation : ptr uw = null;
					heap  newLocation : LP.allocate(numDesired * Type.sizeof);

					check(newLocation, "Failed to resize block")

					heap Data[index].Location : free();

					Data[index].Location = newLocation;

					ret cast(ptr Type, Data[index].Location)
				}

				free exe
				{
					stack index : uw = 0; 
					loop { if index == Length break;
						heap 
						{
							Data[index].Location : free();
							Data[index]          : free();
						}
					}

					heap Data : free();
				}
			}
		}
	} // BlockArray (self)

	(heap)
	{
		(tt Type : type)
		{
			allocate (numDesired : uw) -> ptr Type exe
			{
				stack allocedMemory : ptr Type = null;
				heap  allocedMemory : GlobalAllocs.allocate(Type, numDesired);

				check(allocedMemory, "Failed to globally allocate memory");

				ret allocedMemory
			}

			resize(address : ptr Type, numDesired : uw) -> ptr Type exe
			{
				stack index : uw = 0; loop 
				{
					if index >= GlobalAllocs.Length 
						ret null

					if GlobalAllocs.Data[index].Location == address
						break;
				}

				stack : resizedMemory : ptr Type = null;
				heap  : resizedMemory : GlobalAllocs.resize(Type, numDesired);

				check(resizedMemory, "Failed to globally reallocate memory");

				ret resizedMemory;
			}
		}

		deallocate exe heap GlobalAllocs : deallocate();
	}
}
